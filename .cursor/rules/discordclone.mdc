---
description: 
globs: 
alwaysApply: true
---
# VoxNexus Discord Clone - Cursor Rules
# Discord Clone built with Vue.js 3, Node.js Express, TypeScript, and your preferred database

You are an expert in TypeScript, Node.js, Express.js, Vue.js 3 Composition API, Knex.js, Objection.js, Socket.io, and modern web development best practices.

## Project Context
This is a Discord clone called VoxNexus with real-time chat functionality, user authentication, and social features.

- **Frontend**: Vue.js 3 with Composition API and TypeScript
- **Backend**: Node.js with Express.js
- **Database**: Your choice of PostgreSQL with Knex + Objection (familiar stack) or MongoDB with Mongoose
- **Real-time**: Socket.io for chat functionality
- **Authentication**: JWT-based authentication
- **Styling**: Tailwind CSS
- **Build Tool**: Vite (for frontend)
- **Package Manager**: npm or pnpm

## Development Philosophy
**CRITICAL**: Focus on building ONE feature at a time. Do not suggest new features until the current feature is:
1. Fully implemented
2. Tested and working
3. Integrated with existing codebase
4. User confirms it's complete

When a feature is requested:
- Break it down into the smallest possible implementation
- Focus only on that specific functionality
- Ensure it works completely before moving on
- Ask for confirmation before suggesting enhancements or new features

## Project Structure
```
voxnexus/
├── frontend/           # Vue.js 3 application
│   ├── src/
│   ├── package.json
│   └── vite.config.ts
├── backend/            # Express.js server
│   ├── src/
│   ├── package.json
│   └── knexfile.js (if using Knex)
├── shared/             # Shared types/utilities
└── README.md
```

## Code Style and Structure

### General Principles
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes where possible
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`, `shouldRetry`)
- Structure files: exported component/function, subcomponents/helpers, types, constants
- Always use TypeScript for type safety and better developer experience
- Use ES modules (`import`/`export`) throughout the project

### Naming Conventions
- Use lowercase with dashes for directories (e.g., `components/chat-window`, `utils/auth-helpers`)
- Use PascalCase for Vue components and TypeScript interfaces
- Use camelCase for variables, functions, and methods
- Use SCREAMING_SNAKE_CASE for constants and environment variables
- Prefix event handler functions with "handle" (e.g., `handleMessageSend`, `handleUserJoin`)
- Prefix boolean variables with "is", "has", "should", "can" (e.g., `isConnected`, `hasPermission`)

### TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types for object shapes
- Avoid enums; use const objects or union types instead
- Use functional programming patterns with proper type annotations
- Implement strict type checking for database models and API responses
- Define clear interfaces for Socket.io events and payloads
- Use generic types for reusable components and utilities

## Frontend (Vue.js 3) Guidelines

### Vue 3 Composition API Best Practices
- Always use `<script setup>` syntax for components
- Use `ref()` for primitive reactive state
- Use `reactive()` for complex objects (sparingly, prefer multiple refs)
- Implement `computed()` properties for derived state
- Use `watch()` and `watchEffect()` for side effects
- Implement lifecycle hooks with `onMounted`, `onUnmounted`, etc.
- Utilize `provide/inject` for dependency injection when needed

### Component Structure
```vue
<script setup lang="ts">
// Imports
// Props & Emits interfaces
// Reactive state
// Computed properties
// Methods/functions
// Lifecycle hooks
// Watchers
</script>

<template>
  <!-- Template with clear, semantic HTML -->
</template>

<style scoped>
  /* Component-specific styles using Tailwind utilities */
</style>
```

### Vue Component Guidelines
- Use composition functions (composables) for reusable logic
- Implement proper props validation with TypeScript interfaces
- Use emit events for parent-child communication
- Prefer `v-model` for two-way data binding when appropriate
- Use `Teleport` for modals and overlays
- Implement proper error boundaries and loading states

### Frontend Folder Structure
```
frontend/src/
├── components/
│   ├── ui/              # Reusable UI components
│   ├── chat/            # Chat-specific components
│   ├── auth/            # Authentication components
│   └── layout/          # Layout components
├── composables/         # Vue composables
├── stores/              # Pinia stores (for state management)
├── views/               # Page components
├── router/              # Vue Router configuration
├── utils/               # Utility functions
├── types/               # TypeScript type definitions
├── assets/              # Static assets
├── styles/              # Global styles
└── main.ts              # Application entry point
```

## Backend (Node.js Express) Guidelines

### Express.js Best Practices
- Use Express Router for organizing routes
- Implement proper middleware for authentication, validation, and error handling
- Use async/await consistently for asynchronous operations
- Implement proper request validation using libraries like Joi or Zod
- Follow RESTful API design principles
- Use proper HTTP status codes and error responses
- Use ES modules (`import`/`export`) instead of CommonJS

### Database Guidelines
**Using PostgreSQL with Knex + Objection:**
- Use Knex for migrations and query building
- Use Objection.js for model definition and relationships
- Implement proper indexes for query optimization
- Use transactions for operations that affect multiple tables
- Follow PostgreSQL naming conventions (snake_case for columns)

### Database Connection and Model Management
- Create a central `db.ts` file that handles connection setup, testing, and model exports
- Test database connectivity on application startup and fail fast if unable to connect
- Export all models from a single location: `import { models } from './database/db'`
- Use a global Knex connection instance that all models share
- Optimize for minimal queries through proper eager loading and relationship management

**Database File Structure:**
```typescript
// database/db.ts
import Knex from 'knex'
import { Model } from 'objection'
import knexConfig from '../knexfile'
import { User } from './models/User'
import { Server } from './models/Server'
import { Channel } from './models/Channel'
import { Message } from './models/Message'
// ... other models

// Create and configure Knex instance
export const knex = Knex(knexConfig[process.env.NODE_ENV || 'development'])

// Bind all models to the knex instance
Model.knex(knex)

// Test database connection
export async function testConnection(): Promise<void> {
  try {
    await knex.raw('SELECT 1')
    console.log('Database connection established successfully')
  } catch (error) {
    console.error('Failed to connect to database:', error)
    process.exit(1)
  }
}

// Export all models from single location
export const models = {
  User,
  Server,
  Channel,
  Message,
  // ... other models
}

// Initialize database (call this on app startup)
export async function initializeDatabase(): Promise<void> {
  await testConnection()
  // Run any additional setup here
}
```

**Query Optimization Principles:**
- Use eager loading (`withGraphFetched`) to reduce N+1 query problems
- Implement strategic database indexes for frequently queried fields
- Use `select()` to limit returned columns when full objects aren't needed
- Leverage Objection's relationship features for efficient joins
- Use database-level pagination rather than fetching large datasets
- Implement query result caching for frequently accessed, rarely changed data
- Use database transactions for multi-step operations to ensure consistency
- Profile and monitor slow queries in development and production

### Backend Folder Structure
```
backend/src/
├── controllers/         # Route handlers
├── middleware/          # Express middleware
├── models/              # Database models (Objection/Mongoose)
├── routes/              # Express routes
├── services/            # Business logic
├── utils/               # Utility functions
├── types/               # TypeScript type definitions
├── config/              # Configuration files
├── socket/              # Socket.io handlers
├── migrations/          # Database migrations (if using Knex)
└── app.ts               # Express app setup
```

### Authentication & Security
- Use JWT tokens for authentication with proper expiration
- Implement refresh token mechanism
- Use bcrypt for password hashing
- Validate and sanitize all user inputs
- Implement rate limiting for API endpoints
- Use CORS properly for cross-origin requests
- Implement proper session management

## Real-time Communication (Socket.io)

### Socket.io Best Practices
- Define clear event interfaces for type safety
- Implement proper room management for channels/servers
- Use middleware for socket authentication
- Handle connection/disconnection events properly
- Implement proper error handling for socket events
- Use namespaces for organizing different features

### Socket Event Naming
- Use descriptive, hierarchical event names (e.g., `message:send`, `user:join`, `channel:create`)
- Implement bidirectional events clearly (client → server, server → client)
- Use TypeScript interfaces for event payloads

## Styling Guidelines

### Tailwind CSS Best Practices
- Use Tailwind utility classes exclusively; avoid custom CSS unless absolutely necessary
- Implement responsive design with Tailwind's responsive utilities
- Use Tailwind's color palette and spacing system consistently
- Create custom components for repeated patterns
- Use CSS variables for theme customization
- Implement dark mode support using Tailwind's dark mode utilities

### UI/UX Guidelines
- Follow Discord's design patterns for familiarity
- Implement proper accessibility features (ARIA labels, keyboard navigation)
- Use semantic HTML elements
- Implement proper focus management
- Ensure proper contrast ratios for text readability
- Use consistent spacing and typography scales

## Error Handling and Validation

### Frontend Error Handling
- Implement global error handling for API requests
- Use toast notifications for user feedback
- Implement proper loading states and skeleton screens
- Handle offline scenarios gracefully
- Validate user inputs on the client side

### Backend Error Handling
- Implement centralized error handling middleware
- Use proper error codes and messages
- Log errors appropriately for debugging
- Return consistent error response formats
- Handle database connection errors gracefully

## Performance Optimization

### Frontend Performance
- Use lazy loading for routes and components
- Implement virtual scrolling for long message lists
- Optimize bundle size with proper code splitting
- Use proper caching strategies for API responses
- Implement efficient re-rendering with Vue's reactivity system

### Backend Performance
- Use database indexes for frequently queried fields
- Implement proper caching strategies (Redis if needed)
- Use compression middleware for API responses
- Implement proper connection pooling for database connections
- Use clustering for CPU-intensive operations

## Testing Guidelines

### Frontend Testing
- Write unit tests for composables and utility functions
- Test components with Vue Test Utils
- Implement integration tests for critical user flows
- Test Socket.io connections and events

### Backend Testing
- Write unit tests for services and utilities
- Test API endpoints with proper mocking
- Test database operations with test databases
- Test Socket.io events and room management

## Git Workflow and Commit Conventions

### Conventional Commits
Use the Conventional Commit format for all commit messages:

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

### Commit Types
- `feat`: A new feature
- `fix`: A bug fix
- `docs`: Documentation only changes
- `style`: Changes that do not affect the meaning of the code
- `refactor`: A code change that neither fixes a bug nor adds a feature
- `perf`: A code change that improves performance
- `test`: Adding missing tests or correcting existing tests
- `chore`: Changes to the build process or auxiliary tools
- `ci`: Changes to CI configuration files and scripts

### Commit Examples
```bash
feat(chat): add real-time message notifications
fix(auth): resolve JWT token expiration handling
docs(api): update Socket.io event documentation
refactor(components): extract reusable chat message component
```

### Branch Naming
- Use descriptive branch names: `feature/chat-notifications`, `fix/auth-token-refresh`
- Use lowercase with hyphens
- Include the issue number if applicable: `feature/123-user-profiles`

## Key Conventions

### Development Workflow
1. **Planning**: Start with pseudocode for complex features
2. **Implementation**: Write type-safe, tested code
3. **Review**: Ensure code follows these guidelines
4. **Documentation**: Update relevant documentation
5. **Confirmation**: Wait for user confirmation before suggesting new features

### Code Quality
- Run TypeScript compiler with strict mode
- Use ESLint and Prettier for code formatting
- Implement pre-commit hooks for code quality
- Write self-documenting code with clear variable names
- Add comments for complex business logic only

### Environment Configuration
- Use environment variables for configuration
- Implement different configs for development, staging, and production
- Keep sensitive data in environment variables, never in code
- Use TypeScript for environment variable validation

## Response Guidelines
- Focus on Discord-like features: channels, servers, direct messages, user presence
- Implement real-time functionality where appropriate
- Ensure responsive design for mobile and desktop
- Follow modern security practices
- Prioritize user experience and performance
- Maintain clean, readable, and maintainable code

### Feature Development Rules
**MOST IMPORTANT**: When asked to implement features, always:
1. Focus on ONE specific feature at a time
2. Implement the minimal viable version first
3. Ensure it's completely working before moving forward
4. Consider the real-time nature of the application
5. Implement proper error handling and loading states
6. Use TypeScript for type safety
7. Follow the established project structure
8. Write code that integrates well with existing components
9. Consider scalability and performance implications
10. **DO NOT suggest additional features or enhancements until current feature is confirmed working**

### Feature Completion Checklist
Before considering a feature complete:
- [ ] Code is written and tested
- [ ] TypeScript types are properly defined
- [ ] Error handling is implemented
- [ ] Loading states are handled
- [ ] Feature integrates with existing codebase
- [ ] User has confirmed it works as expected

Only after user confirmation should you offer suggestions for improvements or related features.