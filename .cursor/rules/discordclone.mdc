---
description: 
globs: 
alwaysApply: true
---
# VoxNexus Project Configuration

## Tech Stack
- Framework: Vue.js
- Backend: Node.js with Express
- Database: MongoDB
- Real-time Communication: Socket.IO
- WebRTC: simple-peer
- File Storage: Abstracted storage layer (S3-compatible API or local filesystem)
- File Processing: Separate microservice

## Frontend Structure
- Routing: Vue Router
- Styling: Tailwind CSS
- UI Components: Headless UI
- Icons: Heroicons

## Project Features
- Voice chat implementation using simple-peer
- Video sharing capabilities
- Screen sharing functionality
- Live text chatting with real-time updates
- Private one-to-one messaging between users
- Private group chats with maximum 20 users per group
- Discord-like permission system with fine-grained access controls
- Role hierarchy with inheritance and priority levels
- Dual user identity system:
  - Global username and avatar (account-level)
  - Server-specific usernames and avatars (per server customization)
- Attachment handling for messages (images, files, etc.)

## User Profile System
- Global user profiles with unique usernames and default avatars
- Server-specific profile customization for each server a user joins
- Avatar storage using the attachment system (both global and server-specific)
- Efficient data structure to minimize duplication between global and server profiles
- Profile caching strategy to reduce database queries
- Server-specific display name and avatar override system
- User discovery and friend system using global identities
- @mention system that works with both global and server-specific usernames
- User settings page for managing both global and per-server identities
- Default to global profile when server-specific profile not set

## Attachment System Architecture
- Implement as a separate microservice for scalability
- Maximum file size: 100MB per attachment
- Use storage adapter pattern to abstract storage implementation:
  - Support for S3-compatible services (AWS S3, MinIO, DigitalOcean Spaces)
  - Support for local filesystem storage for development/small deployments
  - Runtime configurable storage backend via environment variables
- Implement unified API for storage operations regardless of backend
- Handle file uploads with configurable chunk size for large files
- Process attachments asynchronously (image resizing, virus scanning)
- Store metadata in MongoDB, file content in selected storage backend
- Implement file type restrictions and size limits
- Generate thumbnails for image attachments
- Support progress tracking for uploads
- Include caching layer for frequently accessed attachments
- Implement automatic migration tools between storage backends
- Implement chunked uploads for files approaching the 100MB limit
- Add client-side file size validation before upload attempts

## File Structure Conventions
- Client-side code in /client directory
- Server-side code in /server directory
- Vue components in /client/src/components
- Vue views in /client/src/views
- API routes in /server/api
- MongoDB models in /server/models
- Socket handlers in /server/sockets
- Attachment service in /services/attachments
- Storage adapters in /services/attachments/adapters

## Database Models
- User: Global user account information and authentication
- UserProfile: Global profile with username and avatar
- Server: Server configuration and metadata
- ServerMember: Junction between User and Server with server-specific profile
- Role: Permission definitions and hierarchy
- Channel: Communication channels within servers
- Message: Chat messages with references to attachments
- Attachment: File metadata and storage references
- DirectMessage: Private messages between users
- GroupChat: Small group conversations outside of servers

## Coding Practices
- Use Composition API for Vue components
- Follow RESTful patterns for API endpoints
- Use Socket.IO namespaces for different features
- Implement WebRTC peer connections for real-time media
- Use MongoDB schemas with proper indexing for permission checks
- Implement role-based access control (RBAC) system
- Store user profiles with server-specific customizations
- Use streaming for large file uploads and downloads
- Implement proper MIME type validation for security
- Use dependency injection for storage implementations
- Apply factory pattern for creating storage adapter instances
- Configure Express and Node.js to handle 100MB file uploads
- Implement resumable uploads for better user experience with large files
- Use content-based file deduplication to save storage space